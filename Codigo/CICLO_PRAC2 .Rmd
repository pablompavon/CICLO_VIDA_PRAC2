---
title: 'Tipología y ciclo de vida de los datos: PRÁCTICA 2'
author: 'David Durán Olivar & Pablo Martínez Pavón'
date: "Diciembre 2021"
output:
  pdf_document:
    highlight: zenburn
    toc: yes
  html_document:
    highlight: default
    number_sections: yes
    theme: cosmo
    toc: yes
    toc_depth: 2
    includes:
      in_header: 75.584-PEC-header.html
  word_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(eval=T, echo=T)
```

******

El objetivo de la presente práctica será el tratamiento de un dataset.

Se ha elegido el dataset [Prosper loan data](https://www.kaggle.com/shikhar07/prosper-loan-data).

El significado de cada una de las variables puede encontrarse en el siguiente [enlace](https://docs.google.com/spreadsheets/d/1gDyi_L4UvIrLTEC6Wri5nbaMmkGmLQBk-Yx3z0XDEtI/edit#gid=0).

Los datos corresponden a un rango temporal específico, que se definirá durante el análisis de los datos. Por lo tanto, en el contexto de la adquisición de los datos se trata de un archivo único, no habría que plantear un ETL para una carga incremental.

La licencia de estos datos no está especificada en Kaggle.

Los datos con los que se trabajará han sido descargados en formato CSV.

Para el planteamiento de esta actividad se seguirá la metodología CRISP-DM. En el caso de la presente práctica, se implementarán las siguientes fases, esto es:

  1. *Comprensión del negocio*.
  
- Objetivo: Definir el resultado esperado.
- Producto que se obtiene: Objetivo específico del proyecto.
- Ejemplo de tareas: las principales preguntas a responder que se plantearán en el apartado correspondiente.

  2. *Comprensión de los datos*.

- Objetivo: Entender la correspondencia entre los datos y la realidad.
- Producto que se obtiene: entendimiento de los datos.
- Ejemplo: conocer la estructura de los datos, entender como se relacionan entre sí y con el mundo real. Posteriormente, se explica la tipología de los datos y su correspondencia con la realidad.

  3. *Preparación de los datos*.

- Objetivo: adquirir los datos, tratarlos (limpiarlos, filtrarlos, etc.),..
- Producto que se obtiene: dataset preparado para trabajar con él (datos válidos y significativos).
- Ejemplo: limpieza de datos (detección de datos vacíos y nulos, no consideración de datos redundantes, errores de formato, etc.), reducción de dimensiones,etc.

  4. *Modelado*.
  
- Objetivo: Desarrollar un modelo que en base al dataset disponible permita lograr el objetivo propuesto en la primera fase.
- Producto que se obtiene: Modelo para predecir si el producto presenta las caracerísticas adecuadas para su venta.
- Ejemplo: partiendo de que el resultado esperado fuese una variable categórica (OK o NO_OK), se trataría de un modelo (por ejemplo, logístico)    para predecir la posibilidad de que el solicitante vaya a incurrir en morosidad.

  5. *Evaluación*.
  
- Objetivo: testear el sistema de predicción con nuevos datos y validad su correcto funcionamiento.
- Producto que se obtiene: validación del modelo planteado.
- Ejemplo: Comprobar que el modelo tiene sentido desde un punto de vista no solo estadísitco, sino que en el mundo real existen razones para dar    por buenos los resultados del modelo (Relación con la fase de Comprensión del negocio).

La fase de *Implantación* queda fuera del alcance de la presente actividad, por tratarse de un desarrollo teórico sobre el papel.

******

Inicialmente, procedemos a la carga de los datos.

```{r message= FALSE, warning=FALSE}
#lectura
datos<-read.csv("D:/Users/pablo/OneDrive/Escritorio/CICLO PRAC2/prosperLoanData.csv",
                header=T, sep=",")
#attach(datos)

```


# 1. Descripción del Dataset.

En primer lugar, analizamos las dimensiones del dataset.

```{r message= FALSE, warning=FALSE}
#dimensiones
sprintf("El dataset presenta las siguientes dimensiones: %.f registros y %.f variables.",
        dim(datos)[1], dim(datos)[2])

```

Comprobamos si existen valores duplicados:

```{r message= FALSE, warning=FALSE}
#duplicados
summary(duplicated(datos))

```

Se comprueba que no existen valores duplicados.

Previo a la conversión de las variables a su tipo correspondiente, y en base a la explicación facilitada en la web, se describen cada una de las variables correspondientes y el tipo que deberían presentar.

* ListingKey: Clave única para cada listado, el mismo valor que la 'clave' utilizada en el objeto de listing en la API. String (factor).

* ListingNumber: El número que identifica de forma exclusiva el listing para el público tal como se muestra en el sitio web. Integer (factor).

* ListingCreationDate: La fecha en que se creó el listado. Date.

* CreditGrade: La calificación crediticia que se asignó en el momento en que se publicó el anuncio. Se aplica a los anuncios del período anterior a 2009 y solo se completará para esos anuncios. String (factor).

* Term: La duración del préstamo expresada en meses. Integer.

* LoanStatus: El estado actual del préstamo: Cancelled,  Chargedoff, Completed, Current, Defaulted, FinalPaymentInProgress, PastDue. El estado PastDue irá acompañado de un aviso de morosidad. String (factor).

* ClosedDate: La fecha de cierre se aplica a los estados de préstamos Cancelled, Completed, Chargedoff and Defaulted. Date.

* BorrowerAPR: La tasa de porcentaje anual (APR, en castellano TAE) del préstamo. Numeric.

* BorrowerRate: La tasa de interés del prestatario para este préstamo. Numeric.

* LenderYield: El rendimiento del prestamista sobre el préstamo. El rendimiento del prestamista es igual a la tasa de interés del préstamo menos la tarifa de servicio. Numeric.

* EstimatedEffectiveYield: El rendimiento efectivo es igual a la tasa de interés del prestatario (i) menos la tasa de la tarifa de servicio, (ii) menos los intereses no cobrados estimados sobre cancelaciones, (iii) más los cargos por mora cobrados estimados. Aplica para préstamos originados después de julio de 2009. Numeric.

* EstimatedLoss: La pérdida estimada es la pérdida de principal estimada en los charge-offs. Aplica para préstamos originados después de julio de 2009. Numeric.

* EstimatedReturn: El rendimiento estimado asignado al listado en el momento de su creación. El rendimiento estimado es la diferencia entre el rendimiento efectivo estimado y la tasa de pérdida estimada. Aplica para préstamos originados después de julio de 2009. Numeric.

* ProsperRating (numérico): La calificación de Prosper asignada en el momento en que se creó el listing: 0 - N / A, 1 - HR, 2 - E, 3 - D, 4 - C, 5 - B, 6 - A, 7 - AA. Aplica para préstamos originados después de julio de 2009. Integer (factor).

* ProsperRating (Alfa): La calificación de Prosper asignada en el momento en que se creó la cotización entre AA - HR. Aplica para préstamos originados después de julio de 2009. String (factor).

* ProsperScore: Una puntuación de riesgo personalizado creado a partir de datos históricos de Prosper. La puntuación varía de 1 a 10, siendo 10 la mejor puntuación de riesgo o la más baja. Aplica para préstamos originados después de julio de 2009. Integer (factor).

* ListingCategory: La categoría del listado que el prestatario seleccionó al publicar su listado: 0 - No disponible, 1 - Consolidación de deuda, 2 - Mejoras para el hogar, 3 - Negocios, 4 - Préstamo personal, 5 - Uso de estudiantes, 6 - Automóvil, 7- Otro, 8 - Bebé y adopción, 9 - Barco, 10 - Procedimiento cosmético, 11 - Anillo de compromiso, 12 - Préstamos ecológicos, 13 - Gastos del hogar, 14 - Grandes compras, 15 - Médico / dental, 16 - Motocicleta, 17 - RV, 18 - Impuestos, 19 - Vacaciones, 20 - Préstamos para bodas. Integer (factor).

* BorrowerState: La abreviatura de dos letras del estado de la dirección del prestatario en el momento en que se creó el listado. String.

* Ocupación: La ocupación seleccionada por el Prestatario en el momento en que creó el listado. String (factor).

* EmploymentStatus: El estado laboral del prestatario en el momento en que publicó la lista. String (factor).

* EmploymentStatusDuration: La duración en meses del estado laboral en el momento en que se creó la lista. Integer.

* IsBorrowerHomeowner: Un prestatario será clasificado como propietario de vivienda si tiene una hipoteca en su perfil crediticio o proporciona documentación que confirme que es propietario de vivienda. Boolean (factor).

* CurrentInGroup Especifica si el prestatario estaba o no en un grupo en el momento en que se creó la lista. Boolean (factor).

* GroupKey: La clave del grupo al que pertenece el prestatario. El valor será nulo si el prestatario no tiene una afiliación grupal. String.

* DateCreditPulled: La fecha en que se extrajo el perfil de crédito. Date.

* CreditScoreRangeLower: El valor más bajo que representa el rango del puntaje crediticio del prestatario proporcionado por una agencia de calificación crediticia del consumidor. Integer.

* CreditScoreRangeUpper: El valor superior que representa el rango del puntaje crediticio del prestatario proporcionado por una agencia de calificación crediticia del consumidor. Integer.

* FirstRecordedCreditLine: La fecha en que se abrió la primera línea de crédito. Date.

* CurrentCreditLines: Número de líneas de crédito actuales en el momento en que se extrajo el perfil de crédito. Integer.

* OpenCreditLines: Número de líneas de crédito abiertas en el momento en que se extrajo el perfil de crédito. Integer.

* TotalCreditLinespast7years: Número de líneas de crédito en los últimos siete años en el momento en que se extrajo el perfil crediticio. Integer.

* OpenRevolvingAccounts: Número de cuentas renovables abiertas en el momento en que se extrajo el perfil crediticio. Integer.

* OpenRevolvingMonthlyPayment: Pago mensual en cuentas renovables en el momento en que se extrajo el perfil crediticio. Integer.

* InquiriesLast6Months: Número de consultas para pedir crédito en los últimos seis meses en el momento en que se extrajo el perfil de crédito. Integer.

* TotalInquiries: Número total de consultas en el momento en que se extrajo el perfil crediticio. Integer.

* CurrentDelinquencies: Número de cuentas morosas en el momento en que se extrajo el perfil crediticio. Integer.

* AmountDelinquent: Dólares morosos en el momento en que se extrajo el perfil crediticio. Integer.

* DelinquenciesLast7Years: Número de morosidad en los últimos 7 años en el momento en que se extrajo el perfil crediticio. Integer.

* PublicRecordsLast10Years: Número de registros públicos en los últimos 10 años en el momento en que se extrajo el perfil crediticio. Integer.

* PublicRecordsLast12Months: Número de registros públicos en los últimos 12 meses en el momento en que se extrajo el perfil crediticio. Integer.

* RevolvingCreditBalance: Dólares de crédito revolving en el momento en que se extrajo el perfil crediticio. Integer.

* BankcardUtilization: El porcentaje de crédito revolving disponible que se utiliza en el momento en que se extrajo el perfil crediticio. Numeric.

* AvailableBankcardCredit: El crédito total disponible mediante tarjeta bancaria en el momento en que se extrajo el perfil de crédito. Integer.

* TotalTrades: Número de líneas comerciales abiertas en el momento en que se extrajo el perfil crediticio. Integer.

* TradesNeverDelinquent: Número de operaciones que nunca han estado en mora en el momento en que se extrajo el perfil crediticio. Numeric.

* TradesOpenedLast6Months: Número de operaciones abiertas en los últimos 6 meses en el momento en que se extrajo el perfil crediticio. Integer.

* DebtToIncomeRatio: La relación deuda / ingresos del prestatario en el momento en que se extrajo el perfil crediticio. Este valor es nulo si la relación deuda / ingresos no está disponible. Este valor tiene un tope de 10.01 (cualquier relación de deuda a ingresos superior al 1000% se devolverá como 1001%). Numeric.

* IncomeRange: El rango de ingresos del prestatario en el momento en que se creó la lista. String (factor).

* IncomeVerificable: El prestatario indicó que tiene la documentación requerida para respaldar sus ingresos. Boolean (factor).

* StatedMonthlyIncome: El ingreso mensual que el prestatario declaró en el momento en que se creó la lista. Numeric.

* LoanKey: Clave única para cada préstamo. Esta es la misma clave que se usa en la API. String.

* TotalProsperLoans: Número de préstamos Prosper que el prestatario en el momento de crear este listado. Este valor será nulo si el prestatario no ha tenido préstamos anteriores. Integer.

* TotalProsperPaymentsBilled: Número de pagos puntuales que el prestatario realizó sobre los préstamos Prosper en el momento de crear esta lista. Este valor será nulo si el prestatario no ha tenido préstamos anteriores. Integer.

* OnTimeProsperPayments: Número de pagos puntuales que el prestatario había realizado en préstamos Prosper en el momento de crear esta lista. Este valor será nulo si el prestatario no tiene préstamos previos. Integer.

* ProsperPaymentsLessThanOneMonthLate: Número de pagos que el prestatario realizó sobre préstamos Prosper que tenían menos de un mes de retraso en el momento de crear esta lista. Este valor será nulo si el prestatario no ha tenido préstamos anteriores. Integer.

* ProsperPaymentsOneMonthPlusLate: Número de pagos que el prestatario realizó en préstamos Prosper que tenían más de un mes de retraso en el momento en que crearon esta lista. Este valor será nulo si el prestatario no ha tenido préstamos anteriores. Integer.

* ProsperPrincipalBorrowed: Principal total prestado sobre préstamos Prosper en el momento en que se creó la cotización. Este valor será nulo si el prestatario no ha tenido préstamos anteriores. Integer.

* ProsperPrincipal: Principal pendiente de pago de los préstamos Prosper en el momento en que se creó la cotización. Este valor será nulo si el prestatario no ha tenido préstamos anteriores. Numeric.

* ScorexChangeAtTimeOfListing La calificación crediticia del prestatario cambió en el momento en que se extrajo el perfil crediticio. Este será el cambio relativo al último préstamo Prosper del prestatario. Este valor será nulo si el prestatario no ha tenido préstamos anteriores. Integer.

* LoanCurrentDaysDelinquent: El número de días de mora. Integer.

* LoanFirstDefaultedCycleNumber: El ciclo en el que se canceló el préstamo. Si el préstamo no se ha cancelado el valor será nulo. Integer.

* LoanMonthsSinceOrigination: Número de meses desde que se originó el préstamo. Integer.

* LoanNumber: Valor numérico único asociado con el préstamo. Integer.

* LoanOriginalAmount: El monto de origen del préstamo. Integer.

* LoanOriginationDate: La fecha en que se originó el préstamo. Date.

* LoanOriginationQuarter: El trimestre en el que se originó el préstamo. String.

* MemberKey: La clave única que está asociada con el prestatario. Este es el mismo identificador que se utiliza en el objeto miembro de API. String (factor).

* MonthlyLoanPayment: El pago mensual programado del préstamo. Numeric.

* LP_CustomerPayments: Pagos brutos acumulativos previos a la cancelación efectuados por el prestatario sobre el préstamo. Si el préstamo se ha cancelado, este valor excluirá cualquier recuperación. Numeric.

* LP_CustomerPrincipalPayments: Pagos de principal acumulados antes de la cancelación efectuados por el prestatario sobre el préstamo. Si el préstamo se ha cancelado, este valor excluirá cualquier recuperación. Numeric.

* LP_InterestandFees: Intereses acumulados y tarifas pagadas por el prestatario antes de la cancelación. Si el préstamo se ha cancelado, este valor excluirá cualquier recuperación. Numeric.

* LP_ServiceFees: Tarifas de servicio acumuladas pagadas por los inversores que han invertido en el préstamo. Numeric.

* LP_CollectionFees: Comisiones de cobranza acumuladas pagadas por los inversores que han invertido en el préstamo. Numeric.

* LP_GrossPrincipalLoss: El monto de cargo bruto del préstamo. Numeric.

* LP_NetPrincipalLoss: El principal que permanece sin cobrar después de cualquier recuperación. Numeric.

* LP_NonPrincipalRecoverypayments: El componente de interés y tarifa de cualquier pago de recuperación. La política de pagos actual aplica los pagos en el siguiente orden: honorarios, intereses, principal. Numeric.

* PercentFunded: Porcentaje de financiación del préstamo. Numeric.

* Recomendaciones: Número de recomendaciones que tenía el prestatario en el momento en que se creó la lista. Integer.

* InvestmentFromFriendsCount: Número de amigos que hicieron una inversión en el préstamo. Integer.

* InvestmentFromFriends: Monto en dólares de inversiones realizadas por amigos. Integer.

* Inversores: El número de inversores que financiaron el préstamo.

Observamos que en definitiva,se analizan las características generales del préstamo y el perfil del prestatario, posteriomente cada una de las posibles fuentes de deuda (Líneas de crédito, créditos revolving, otros créditos prosper) y los datos del préstamo actual.

Así, los datos corresponden a préstamos 

Antes de realizar el análisis inicial de los datos, se eliminarán las variables del dataset y se onvertirán a los tipos correspondientes las variables.

## ¿Por qué es importante y qué pregunta/problema pretende responder?

[Prosper](https://www.prosper.com/) se fundó en 2005 como el primer mercado de préstamos P2P (peer to peer) en los Estados Unidos. Desde entonces, Prosper ha facilitado más de 14 mil millones $ en préstamos a más de 870.000 personas.

Este dataset ofrece multitud de criterios que nos permiten conocer las diferentes variables que caracterizan el perfil de las personas a las que se ha concedido un crédito desde Prosper. Así, mediante su análisis es posible inferir las características básicas de los préstamos que han salido bien y el perfil de las persoanas que pueden recibir un crédito en base a su perfil económico.

Prosper ofrece una herramienta que si bien funciona como un préstamo bancario, ofrece una herramienta novedosa ya que permite a particulares tanto invertir en estos préstamos y lograr un rédito financiero, como a personas que tienen dificultades para acceder a créditos tradicionales poder acceder a financiación.

Emplea la "Calificación Prosper" para posibles prestatarios basada en la estimación de la empresa de la "tasa de pérdida estimada" de ese prestatario. Según la compañía, esa cifra está "determinada por dos puntajes: (1) el puntaje de crédito, obtenido de una agencia oficial de informes crediticios, y (2) el scoring de Prosper, calculado internamente según la población de Prosper". Las calificaciones de Prosper, de menor riesgo a mayor riesgo, están etiquetadas como AA, A, B, C, D, E y HR ("Alto riesgo").

Prosper rating   Estimated Average Annual Loss Rate
--------------   ---------------------------------- 
  AA 	                    0.00–1.99%
  A 	                    2.00–3.99%
  B 	                    4.00–5.99%
  C 	                    6.00–8.99% 
  D 	                    9.00–11.99%
  E 	                    12.00–14.99%
  HR 	                    15.00%+

De 2006 a 2009, Prosper operó un modelo de tasa variable. Prosper actuó como un mercado de subastas en línea al estilo de eBay, en el que los prestamistas y los prestatarios determinaban en última instancia las tasas de los préstamos mediante un sistema holandés similar a una subasta. 

En agosto de 2008, aproximadamente el 18,5% de todo el dinero prestado a través de Prosper desde el inicio (febrero de 2006) hasta junio de 2008 se encontraba en algún tipo de morosidad. Además, más del 35% de todos los préstamos que se originaron en febrero de 2007 se encontraban en algún tipo de mora.

A partir del 19 de diciembre de 2010, Prosper presentó un nuevo folleto a la SEC (Securities and Exchange Commission), cambiando su modelo de negocio para utilizar tasas preestablecidas determinadas únicamente por Prosper con base en una fórmula que evalúa el riesgo crediticio de cada posible prestatario. Con el nuevo enfoque, los prestamistas ya no determinan la tasa del préstamo mediante el descubrimiento de precios en una subasta. En su lugar, simplemente eligen si invierten o no a la tasa que el algoritmo de fijación de precios de préstamos de Prosper asigna al préstamo después de analizar el informe crediticio y la información financiera del prestatario.

Al 24 de enero de 2010, Prosper informó que el 22,45% de todo el dinero prestado desde el inicio se había cancelado y un 2,51% adicional estaba en mora pero aún no se había cancelado. Las tasas de cancelación por categoría de puntaje de crédito oscilaron entre el 11.57% del dinero prestado a prestatarios con un puntaje de crédito de 760 o más y el 44.30% del dinero prestado a prestatarios con un puntaje de crédito por debajo de 600. Eric's Credit Community informó resultados de morosidad generalmente consistentes, con una tasa de morosidad de 24 meses por grado de crédito para préstamos originados después del 1 de enero de 2006, que oscila entre el 11,8% para los préstamos 'AA' y el 61,6% para los préstamos 'HR'. Las tasas de cancelación en muchos casos excedieron los intereses recibidos en las categorías de préstamos, lo que resultó en un rendimiento negativo. Erics informó que el rendimiento medio de los inversores de Prosper fue negativo del 2,00% y el rendimiento medio negativo de 2,28.

Después del relanzamiento de Prosper en julio de 2009 y la aplicación de directrices crediticias más estrictas para los prestatarios, la tasa de impago de préstamos de Prosper se ha reducido significativamente. El porcentaje de todos los préstamos con más de 6 meses de antigüedad y más de 1 mes de atraso se redujo a menos del 4%. Al 11 de agosto de 2010, los 4 meses que coinciden con estos criterios representan el porcentaje más bajo de retrasos en los pagos que Prosper ha visto desde el inicio.

[Fuente](https://en.wikipedia.org/wiki/Prosper_Marketplace)

Según informes del gobierno americano, el efecto de estos préstamoes es positivo, ya que después de la solicitud, los puntajes crediticios de los prestatarios aumentan y las tasas de utilización de sus tarjetas de crédito caen en relación con los no prestatarios a corto plazo. A largo plazo, los niveles de deuda total de los prestatarios son más altos que los de los no prestatarios. Las diferencias en la deuda hipotecaria son particularmente grandes y aumentan con el tiempo. A pesar del aumento de los niveles de deuda en relación con los no prestatarios, las tasas de morosidad de los prestatarios son significativamente más bajas.

[Fuente](https://www.federalreserve.gov/econres/feds/files/2019022pap.pdf)

Así, hemos identificado los siguientes objetivos:

Además, también recogen las viviendas de nueva construcción, lo cual puede servir para hacer una comparativa con construcciones modernas.

Entre las preguntas que buscamos responder:

- Caracterización del perfil de las personas que piden este tipo de créditos.
- Distribución por Estados.
- Préstamos característicos (duración y cantidad solicitada).
- Descubrir el modelo del ProsperScoring.
- Descubrir que información del perfil crediticio permite inferir si se va a incurrir en morosidad.
- Descubrir las caracter´siticas de un préstamo que siempre es devuelto.

[Web Prosper - Enlace a los listings](https://www.prosper.com/listings)

# 2. Integración y selección de los datos de interés a analizar.

Mediante la selección de variables, realizamos una primera reducción de la dimensionalidad del dataset. Se han decidido eliminar las siguientes variables porque se considera que no significativas de cara a resolver las preguntas planteadas:

- ListingKey
- ListingNumber
- ProsperRating (numeric)
- GroupKey
- CurrentlyInGroup
- TotalCreditLinespast7years
- DelinquenciesLast7Years
- PublicRecordsLast10Years
- LoanKey
- LoanNumber
- LoanOriginationQuarter
- MemberKey
- Recommendations
- InvestmentFromFriendsCount
- InvestmentFromFriendsAmount

Las razones por las que se han descartado, son variadas: el tipo de dato, su antiguedad, etc.

```{r message= FALSE, warning=FALSE}
#eliminacion variables
datos$ListingKey<-NULL
datos$ListingNumber<-NULL
datos$ProsperRating..numeric.<-NULL
datos$GroupKey<-NULL
datos$CurrentlyInGroup<-NULL
datos$TotalCreditLinespast7years<-NULL
datos$DelinquenciesLast7Years<-NULL
datos$PublicRecordsLast10Years<-NULL
datos$LoanKey<-NULL
datos$LoanNumber<-NULL
datos$LoanOriginationQuarter<-NULL
datos$MemberKey<-NULL
datos$Recommendations<-NULL
datos$InvestmentFromFriendsAmount<-NULL
datos$InvestmentFromFriendsCount<-NULL

```

Además, observamos ciertas relaciones entre las variables:

EstimatedEffectiveYield = EstimatedLoss + EstimatedReturn

Podemos sumar en una única variable, los pagos atrasados de los créditos Prosper. (ProsperPaymentsOneMonthPlusLate+ProsperPaymentsLessThanOneMonthLate->ProsperPaymentsLate)

En lo referido al perfil del solicitante:

Para caracterizar las líneas revolving, solo mantendremos las siguientes variables:
- OpenRevolvingMonthlyPayment
- RevolvingCreditBalance

Así, sabremos la cantidad que se debe y la cuota mensual.

Para conocer las líneas de crédito, solo tendremos en cuenta el número de líneas en uso (abiertas).

Se mantienen las variables de solicitudes (inquiries).

Respecto al crédito bancario y los trades mantenemos las variables disponibles en este punto.

Respecto a los préstamos previos, también reduciremos el número de variables.
No mantenemos el número concreto de préstamos prosper previos, pero sí las coutas pagadas en plazo y fuera de el, la cantidad de dinero que se debe, no así la solicitada, etc. 

```{r message= FALSE, warning=FALSE}
#eliminacion variables
datos$EstimatedLoss<-NULL
datos$EstimatedReturn<-NULL

#datos$ProsperPaymentsLate<-rowSums(datos[,c("ProsperPaymentsLessThanOneMonthLate",
#"ProsperPaymentsOneMonthPlusLate")], na.rm=TRUE)
datos$ProsperPaymentsLessThanOneMonthLate<-NULL
datos$ProsperPaymentsOneMonthPlusLate<-NULL

datos$OpenRevolvingAccounts<-NULL

datos$CurrentCreditLines<-NULL

datos$OnTimeProsperPayments<-datos$OnTimeProsperPayments/datos$TotalProsperPaymentsBilled
datos$TotalProsperPaymentsBilled<-NULL
datos$ProsperPrincipalBorrowed<-NULL

datos$ScorexChangeAtTimeOfListing<-NULL

datos$LoanFirstDefaultedCycleNumber<-NULL
datos$LoanMonthsSinceOrigination<-NULL

```

Se convierte cada variable al tipo que se ha indicado durante la descripción de las variables.

```{r message= FALSE, warning=FALSE}
#conversion dates
datos$ListingCreationDate<- as.Date(datos$ListingCreationDate)
datos$ClosedDate<- as.Date(datos$ClosedDate)
datos$DateCreditPulled<- as.Date(datos$DateCreditPulled)
datos$LoanOriginationDate<- as.Date(datos$LoanOriginationDate)
datos$FirstRecordedCreditLine<- as.Date(datos$FirstRecordedCreditLine)

#conversion factors
datos$CreditGrade<-as.factor(datos$CreditGrade)
#creamos un unico nivel Past Due
datos$LoanStatus[(grepl("Past Due",datos$LoanStatus))]<-"Past Due"
datos$LoanStatus<-as.factor(datos$LoanStatus)
datos$ProsperRating<-as.factor(datos$ProsperRating..Alpha.)
datos$ProsperRating..Alpha.<-NULL
#datos$ProsperScore<-as.factor(datos$ProsperScore)
datos$ListingCategory<-as.factor(datos$ListingCategory..numeric.)
datos$ListingCategory..numeric.<-NULL
datos$BorrowerState<-as.factor(datos$BorrowerState)
datos$Occupation<-as.factor(datos$Occupation)
datos$EmploymentStatus<-as.factor(datos$EmploymentStatus)
datos$IsBorrowerHomeowner<-as.factor(datos$IsBorrowerHomeowner)
datos$IncomeRange<-as.factor(datos$IncomeRange)
datos$IncomeVerifiable<-as.factor(datos$IncomeVerifiable)

```

Analizamos la estructura del dataset:

```{r message= FALSE, warning=FALSE}
# estructura
str(datos)

```

También algunos de los principales parámetros estadísticos:

```{r message= FALSE, warning=FALSE}
# resumen 
summary(datos)

```

```{r message= FALSE, warning=FALSE}
#dimensiones
sprintf("El dataset presenta las siguientes dimensiones: %.f registros y %.f variables.",
        dim(datos)[1], dim(datos)[2])

```

Observamos como los préstamos en estado Complete o Charged off, no presentan la mayoría de los datos del perfil económico de los usuarios por lo que podremos separaremos tras ver que porcentaje representan sobre el total de los datos y algunos de los parámetros generales.

```{r message= FALSE, warning=FALSE}
#pie
pie(table(datos$LoanStatus), main="Distribución por estado del préstamo")

```

Observamos que Completed y Chargedoff son la segunda y tercera categoría con mayor número de registros respectivamente. Cancelled y FinalPaymentInProgress tienen un peso ínfimo sobre el total de los registros.

Comprobamos la distribución de los préstamos por número de meses y por cantidad solicitada:

```{r message= FALSE, warning=FALSE}
#term
plot(as.factor(datos$Term), main="Distribución por meses solicitados",xlab="Meses", ylab="Ocurrences")

```

Se observa que de forma mayoritaria se solicitan préstamos a 36 meses.

```{r message= FALSE, warning=FALSE}
library(ggplot2)

ggplot(aes(x = LoanOriginalAmount ) , data = datos) + 
  geom_histogram(aes(), binwidth=1500, colour="red", lwd=0.2) +
   ggtitle("Distribución de las cantidades solicitadas") +
  xlab("Amount ($)") + ylab("Ocurrences")

```

Observamos que predominantemente se trata de préstamos por debajo de los 15.000 dólares.

```{r message= FALSE, warning=FALSE}
ggplot(aes(x = LoanOriginalAmount ) , data = datos) + 
  geom_histogram(aes(fill=IsBorrowerHomeowner), binwidth=1500, colour="grey20", lwd=0.2) +
  scale_x_continuous(breaks=seq(0,max(datos$LoanOriginalAmount), 1500))+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+
  xlab("Amount ($)") + ylab("Ocurrences")

```

Se comprueba como en los préstamos que solicitan mayor cantidad, presenta un mayor porcentaje de propietarios de viviendas.

```{r message= FALSE, warning=FALSE}
ggplot(aes(x = LoanOriginalAmount ) , data = datos) + 
  geom_histogram(aes(fill=IncomeRange), binwidth=1500, colour="grey20", lwd=0.2) +
  scale_x_continuous(breaks=seq(0,max(datos$LoanOriginalAmount), 1500))+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+
  xlab("Amount ($)") + ylab("Ocurrences")

```

Sí que se observa una cierta relación entre la cantidad solicitada y el rango salarial. Los mayores préstamos son solicitados por personas en los escalones más altos de salario.

Comprobamos esta hipótesis:

```{r message= FALSE, warning=FALSE}
#correlación entre amount y month_loan_duration
ggplot(datos, aes(x=StatedMonthlyIncome, y=LoanOriginalAmount)) + 
  geom_point()+
  geom_smooth(method=lm)

```

Se observa que existen valores anómalos que impiden una correcta graficación, posteriormente se podrá volver a tratar estos datos.

```{r message= FALSE, warning=FALSE}
#correlación entre amount y month_loan_duration
ggplot(datos, aes(x=StatedMonthlyIncome, y=LoanOriginalAmount)) + 
  geom_point()+
  geom_smooth(method=lm)+xlim(0,150000)

```

La densidad representada impide observar claramente si existe correlación, pero en principio, parece que para una misma cantidad solicitada, existen solicitantes con muy diferente nivel de ingresos mensuales.

Graficamos otras variables que, ya de primeras, consideramos significativas a la hora de solicitar un préstamo.

```{r message= FALSE, warning=FALSE}
plot(datos$Occupation, main="Distribución por profesión",xlab="Profesiones", ylab="Ocurrences")

```

Presentamos los resultados de la gráfica anterior, en una tabla

```{r message= FALSE, warning=FALSE}
library(dplyr)
tabla.ocupacion <- datos %>%                             
  group_by(Occupation) %>%
  summarise(count = n(),media=mean(LoanOriginalAmount))

#ordenado por ocurrences
head(tabla.ocupacion[order(tabla.ocupacion$count, decreasing=TRUE),],10)
#ordenado por media de lospréstamos solicitados
head(tabla.ocupacion[order(tabla.ocupacion$media, decreasing=TRUE),],10)

remove(tabla.ocupacion)

```

Observamos que por número de ocurrencias la categoría con más registros es Other. En el caso de por importe medio solicitado, vemos que en la mayoría son grupos con pocos registros; las diferencias entre ambas ordenaciones son reseñables, solo coincidiendo en ambos grupos Executive.


```{r message= FALSE, warning=FALSE}
plot(as.factor(datos$BorrowerState), main="Distribución por Estado de residencia",xlab="Estados", ylab="Ocurrences")

```

Observamos que gráficamente tampoco es posible interpretar todas las columnas, aunque sí que se comprueba que la distribución no es semejante entre estados. Generamos una tabla con estos datos.

```{r message= FALSE, warning=FALSE}
tabla.estados <- datos %>%                             
  group_by(BorrowerState) %>%
  summarise(count = n(),media=mean(LoanOriginalAmount))

#ordenado por ocurrences
head(tabla.estados[order(tabla.estados$count, decreasing=TRUE),],10)
#ordenado por media de lospréstamos solicitados
head(tabla.estados[order(tabla.estados$media, decreasing=TRUE),],10)

remove(tabla.estados)

```

En este caso, tampoco hay grandes semejanzas entre ambas tablas, Con la excepción de CA y TX (California y Texas). California destaca por el número de préstamos, teniendo más del doble que el segundo estado de la tabla. Si nos vamos al dinero medio comprobamos que no existe tanta diferencia entre los estados.

```{r message= FALSE, warning=FALSE}
plot(as.factor(datos$EmploymentStatus), main="Distribución por estado laboral",xlab="Estado laboral", ylab="Ocurrences")

```

```{r message= FALSE, warning=FALSE}
tabla.empleo <- datos %>%                             
  group_by(EmploymentStatus) %>%
  summarise(count = n(),media=mean(LoanOriginalAmount))

#ordenado por ocurrences
head(tabla.empleo[order(tabla.empleo$count, decreasing=TRUE),],10)
#ordenado por media de lospréstamos solicitados
head(tabla.empleo[order(tabla.empleo$media, decreasing=TRUE),],10)

remove(tabla.empleo)

```

```{r message= FALSE, warning=FALSE}
ggplot(aes(x = EmploymentStatusDuration ) , data = datos) + 
  geom_histogram(aes(), binwidth=12, colour="grey20", lwd=0.2) +
   ggtitle("Distribución de los meses con trabajo") +
  xlab("Meses") + ylab("Ocurrences")

```

Se ve que por lo general quienes solicitan préstamos tienen una menor cantidad de tiempo trabajado.

Con estos primeros análisis es posible hacer una primera descripción del perfil de persona que solicita estos préstamos:
- Trabajadores por cuenta ajena temporales o indefinidos.
- Poco tiempo trabajado.
- Préstamos a 36 meses y menos de 15.000 dólares.

```{r message= FALSE, warning=FALSE}
#correlación entre amount y month_loan_duration
ggplot(datos, aes(x=Term, y=LoanOriginalAmount)) + 
  geom_point()+
  geom_smooth(method=lm)

```

Observamos que no hay una relación directa entre los meses que dura el préstamo y la cantidad solicitada.

```{r message= FALSE, warning=FALSE}
tabla.rating <- datos %>%                             
  group_by(ProsperRating) %>%
  summarise(count = n(),media=mean(ProsperScore,na.rm = T))

#ordenado por ocurrences
head(tabla.rating[order(tabla.rating$count, decreasing=TRUE),],10)
#ordenado por media de lospréstamos solicitados
head(tabla.rating[order(tabla.rating$media, decreasing=TRUE),],10)

remove(tabla.rating)

``` 

Se comprueba que predominan los registros sin valor y que a la vista del score medio hay una correspondencia con el rating, si bien para las categorías más bajas E y HR, la distancia entre categorías se diluye.

```{r message= FALSE, warning=FALSE}
#correlación entre amount y month_loan_duration
ggplot(datos, aes(x=BorrowerAPR, y=LoanOriginalAmount)) + 
  geom_point()+
  geom_smooth(method=lm)

```

No existe una correlación clara entre la cantidad solicitada y el TAE que presenta el préstamo.

Mostramos la correlación entre todas las variables:

```{r message= FALSE, warning=FALSE}
#convertimos las variables categóricas a sus valores numéricos
#datos.num<-sapply(datos,as.numeric)
#datos.num<-scale(datos.num)
#library(corrplot)
#diagrama de correlación
#corrplot(cor(datos.num), type = "upper", order = "hclust", 
#         tl.col = "black", tl.srt = 45, na.omit=T)
#remove(datos.num)

```

Se deben limpiar los registros antes de analizar la correlación.

# 3. Limpieza de los datos.

Aprovechamos la limpieza de cada variable para detectar anomalías y analizarla en detalle.

### ListingCreationDate

```{r message= FALSE, warning=FALSE}
summary(datos$ListingCreationDate)

```
En el caso de esta variable, no hay valores que limpiar, y comprobamos que la creación de los listings va de 2005 a 2014.

### Credit Grade

En este caso, como solo es válido antes del 2009 lo juntamos con Prosper Rating, ya que presentan los mismos niveles con la excepción de NC (No Credit).

```{r message= FALSE, warning=FALSE}
#niveles
levels(datos$CreditGrade)
levels(datos$ProsperRating)
#resumen
summary(datos$CreditGrade)
#pasamos los valores a rating
datos$ProsperRating[datos$ProsperRating==""]<-datos$CreditGrade
datos$CreditGrade<-NULL

```

Observamos que los valores vacíos se representan mediante "". Se han juntado las dos variables, se sabría diferenciar el origen de los datos de la nueva variable en función de la fecha.

### Term

```{r message= FALSE, warning=FALSE}
summary(datos$Term)

```

No existen valores vacíos. Ya se graficó anteriormente, viendo que solo existen 3 niveles: 12, 36 y 60 meses.

### LoanStatus

```{r message= FALSE, warning=FALSE}
summary(datos$LoanStatus)

```

No existen valores vacíos. Ya se graficó anteriormente.

### ClosedDate

```{r message= FALSE, warning=FALSE}
summary(datos$ClosedDate)

```

Se observa que hay muchos valores vacíos, esto se debe a que hay muchos préstamos que no están cerrados.

Los valores son congruentes con los de las fechas de creación.

Podemos asignar una fecha estimada de cierre en base al term, si suponemos meses de 30 días; sabríamos que fechas son reales y cuales estimadas en base al status.

```{r message= FALSE, warning=FALSE}
# asignamos nueva fecha
datos$ClosedDate[is.na(datos$ClosedDate)]<-datos$ListingCreationDate+datos$Term*30

summary(datos$ClosedDate)

```

Comprobamos que no habría valores vacíos.

### BorrowerAPR

```{r message= FALSE, warning=FALSE}
summary(datos$BorrowerAPR)
boxplot(datos$BorrowerAPR, horizontal = T)

```

Observamos una gran variabilidad del TAE. Existen 25 valores vacíos que pueden completarse mediante regresión. Mediante el boxplot hemos identificado 3 valores que podrían ser tratados como outlier, pero nada indica que sean incorrectos.

```{r message= FALSE, warning=FALSE}
reg.lin.apr<-lm(BorrowerAPR~BorrowerRate+LenderYield,datos,na.action=na.omit)
summary(reg.lin.apr)

```

Conseguimos un buen modelo con un R2 ajustado elevado y en el que todas las variables son significativas. Con estos valores predecimos la variable APR.

```{r message= FALSE, warning=FALSE}
datos$BorrowerAPR[is.na(datos$BorrowerAPR)]<-predict(reg.lin.apr)

remove(reg.lin.apr)

summary(datos$BorrowerAPR)

```

Se comprueba que se han eliminado los na.

### BorrowerRate

```{r message= FALSE, warning=FALSE}
summary(datos$BorrowerRate)
boxplot(datos$BorrowerRate, horizontal = T)

```
En este caso, no hay valores vacíos y se detectan los mismos outliers.

### LenderYield

```{r message= FALSE, warning=FALSE}
summary(datos$LenderYield)
boxplot(datos$LenderYield, horizontal = T)

```

Esta variable se comporta como las anteriores. Parecen presentar un elevado grado de correlación.

```{r message= FALSE, warning=FALSE}
library(corrplot)
#diagrama de correlación
corrplot(cor(datos[,5:7]), type = "upper", order = "hclust", 
         tl.col = "black", tl.srt = 45, na.omit=T)

```
Se confirma, por lo que procedemos a descartar las dos últimas variables.

```{r message= FALSE, warning=FALSE}
datos$BorrowerRate<-NULL
datos$LenderYield<-NULL

```

### EstimatedEffectiveYield

```{r message= FALSE, warning=FALSE}
summary(datos$EstimatedEffectiveYield)
boxplot(datos$EstimatedEffectiveYield,horizontal = T)

```

Comprobamos que existen muchos valores vacíos. C orresponden a préstamos previos a 2009 y que no están actualmente en curso.

Parece existir una relación con la variable ProsperScore, que presenta los mismos NA. Se detectan outliers en los valores negativos.

Trataremos como outliers los datos que se alejen 3 desviaciones estándar respecto a la media.

```{r message= FALSE, warning=FALSE}
datos$EstimatedEffectiveYield[datos$EstimatedEffectiveYield<(mean(datos$EstimatedEffectiveYield,
                                  na.rm = T)-3*sd(datos$EstimatedEffectiveYield,na.rm = T))]<-NA

```

Analizamos la relación con respecto a las variables actualmente tratadas.

```{r message= FALSE, warning=FALSE}
cor(datos[,5:6],use="complete.obs")

```

Se comprueba un elevado grado de correlación, sin embargo en este caso emplearemos otro método para inferir los valores. Plantemos usar KNN para inferir el valor de EstimatedEffectiveYield en los registros vacíos.

```{r message= FALSE, warning=FALSE}
#library(VIM)
#datos$EstimatedEffectiveYield[is.na(datos$EstimatedEffectiveYield)] <- 
# kNN(datos)$EstimatedEffectiveYield

```

No es posible emplear este método por el tamaño del dataset, ya que se genera un vector de más de 15 Gb.

### ProsperScore

```{r message= FALSE, warning=FALSE}
summary(datos$ProsperScore)
boxplot(datos$ProsperScore,horizontal = T)

```

No se observan outliers en la representación gráfica, sin embargo vemos que hay valores por encima de 10 que se marca como el valor máximo. El número de NAs es igual al de la variable anterior. Tal y como se indicó en el apartado anterior, se analizó la relación entre los niveles de rating y el score medio podemos emplear estos datos para completarlo.

```{r message= FALSE, warning=FALSE}
#eliminamos los valores superiores a 10
datos$ProsperScore[datos$ProsperScore>10]<-NA

#media de rating
media.rating<-aggregate(x=datos$ProsperScore, 
                              by= list(datos$ProsperRating),FUN=mean,na.rm=T)
rownames(media.rating)<-levels(media.rating$Group.1)

for (i in (1:(dim(datos)[1])))
  {
#asignamos a los valoresvacíos 
      if  (is.na(datos$ProsperScore[i])){
        datos$ProsperScore[i]<-as.integer(media.rating[datos$ProsperRating[i],2])
      }
      
}

remove(i,media.rating)

```

Observamos que continúan existiendo valores con NA.

### BorrowerState

```{r message= FALSE, warning=FALSE}
summary(datos$BorrowerState)

```
Observamos que existen 5.515 valores vacíos (""), en este caso con los datos disponibles no es posible indagar el valor a asignar.

### Occupation

```{r message= FALSE, warning=FALSE}
summary(datos$Occupation)

```

En este caso al valor vacío (""), le asignamos el valor other.

```{r message= FALSE, warning=FALSE}
datos$Occupation[datos$Occupation==""]<-"Other"

```


### EmploymentStatus

```{r message= FALSE, warning=FALSE}
summary(datos$EmploymentStatus)

```

A los datos vacíos le asignamos Not available

```{r message= FALSE, warning=FALSE}
datos$EmploymentStatus[datos$EmploymentStatus==""]<-"Not available"

```

### EmplymentStatusDuration

```{r message= FALSE, warning=FALSE}
summary(datos$EmploymentStatusDuration)
boxplot(datos$EmploymentStatusDuration, horizontal = T)

```

Se observa que hay valores que detecta como outliers, pero aunque la mayoría de las personas que soliciten estos créditos tengan poco tiempo trabajo, también pueden ser solicitados por gente que tenga 60 años trabajados.

A los datos sin valor, le asignamos el valor cero.

```{r message= FALSE, warning=FALSE}
datos$EmploymentStatusDuration[is.na(datos$EmploymentStatusDuration)]<-0

```

### IsBorrowerHomeowner

```{r message= FALSE, warning=FALSE}
summary(datos$IsBorrowerHomeowner)

```

Se comprueba que no hay datos vacíos. Se observa que la proporción entre personas que son propietarias de una casa y personas que no es semejante.

### DateCreditPulled

```{r message= FALSE, warning=FALSE}
summary(datos$DateCreditPulled)

```

No existen valores vacíos. Los datos parecen lógicos. Comprobamos que en su mayoría los valores coinciden con la fecha de creación de listing.

```{r message= FALSE, warning=FALSE}
summary(datos$DateCreditPulled==datos$ListingCreationDate)

```

Si los convertimos a numero, observamos que la correlación entre ambas variables es muy elevada. Eliminamos la variable.

```{r message= FALSE, warning=FALSE}
cor(sapply(datos[,c(1,13)],as.numeric))
datos$DateCreditPulled<-NULL
```

### CreditScoreRangeLower

```{r message= FALSE, warning=FALSE}
summary(datos$CreditScoreRangeLower)
boxplot(datos$CreditScoreRangeLower, horizontal = T)

```

Existen valores vacíos. Su gestión se deja para posteriormente.

### CreditScoreRangeUpper

Hacemos lo mismo que en la variable anterior.

```{r message= FALSE, warning=FALSE}
summary(datos$CreditScoreRangeUpper)
boxplot(datos$CreditScoreRangeUpper, horizontal = T)
```

Existen valores vacíos. Su gestión se deja para posteriormente.

### FirstRecordedCreditLine

```{r message= FALSE, warning=FALSE}
summary(datos$FirstRecordedCreditLine)

```

Existen valores vacíos. Entendemos que son las personas que no cuentan con una línea de crédito. Dejaremos el valor vacío.

### OpenCreditLines

```{r message= FALSE, warning=FALSE}
summary(datos$OpenCreditLines)

```

Observamos que existen más registros vacíos que sin fecha. En los que no consta fecha se introduce un cero, en los que sí se introducirá el valor medio.

```{r message= FALSE, warning=FALSE}
media<-as.integer(mean(datos$OpenCreditLines,na.rm = T))

for (i in (1:(dim(datos)[1])))
  {
#asignamos a los valoresvacíos 
      if  (is.na(datos$OpenCreditLines[i])){
        if(is.na(datos$FirstRecordedCreditLine[i])){
          datos$OpenCreditLines[i]<-0
        }
        else{
          datos$OpenCreditLines[i]<-media
        }
      }
      
}

remove(i,media)

```

### OpenRevolvingMonthlyPayment

```{r message= FALSE, warning=FALSE}
summary(datos$OpenRevolvingMonthlyPayment)
boxplot(datos$OpenRevolvingMonthlyPayment,horizontal = T)

```

No hay datos vacíos, aunque observamos valores muy altos que podríamos considerar anormales.

```{r message= FALSE, warning=FALSE}
#valores más altos
head(datos[order(datos$OpenRevolvingMonthlyPayment, decreasing=TRUE),],10)

```

Si las comparamos con respecto a los ingresos mensuales declarados, observamos que la mayoría de las cuotas revolving más altas se corresponden a los mayores ingresos correspondientes.

Aun así, corregimos con la medialos que presenten una cuota mayor que los ingresos.

```{r message= FALSE, warning=FALSE}
datos$OpenRevolvingMonthlyPayment[datos$OpenRevolvingMonthlyPayment>
                                    datos$StatedMonthlyIncome]<-as.integer(
                                      mean(datos$OpenRevolvingMonthlyPayment))

```

### InquiriesLast6Month

```{r message= FALSE, warning=FALSE}
summary(datos$InquiriesLast6Months)

boxplot(datos$InquiriesLast6Months, horizontal = T)

```

Existen valores muy altos que podrían considerarse anómalos. Considerando un total de 20 días "laborables" al mes, en 6 meses el caso máximo requeriría al menos una solicitud el 87,5% de los días, por lo tanto es posible.

En el caso de los valores vacíos, consideramos que no han existido peticiones.

```{r message= FALSE, warning=FALSE}
datos$InquiriesLast6Months[is.na(datos$InquiriesLast6Months)]<-0

```

### TotalInquiries

```{r message= FALSE, warning=FALSE}
summary(datos$TotalInquiries)

boxplot(datos$TotalInquiries, horizontal = T)

```

COmo en el caso anterior, observamos valores muy grandes que se alejan de la distribución. No disponemos del conocimiento para saber si puede existir un solicitante con este perfil. Además, en este caso el período de tiempo en el que se han generado dichas solicitudes no se conoce y será diferente para cada solicitante.

Comprobamos que los valores disponibles son correctos.

```{r message= FALSE, warning=FALSE}
summary(datos$TotalInquiries>=datos$InquiriesLast6Months)

```
Para los valores NA, asignaremos el valor de los 6 meses. Habiendo ya sido corregido previamente, siempre asignaremos un valor válido.

```{r message= FALSE, warning=FALSE}
datos$TotalInquiries[is.na(datos$TotalInquiries)]<-datos$InquiriesLast6Months

```

### CurrentDeliquincies

```{r message= FALSE, warning=FALSE}
summary(datos$CurrentDelinquencies)
boxplot(datos$CurrentDelinquencies, horizontal = T)

```

Vemos que normalmente la distribución de dicha variable presenta ceros; este valor será asignado a los valores vacíos.

```{r message= FALSE, warning=FALSE}
datos$CurrentDelinquencies[is.na(datos$CurrentDelinquencies)]<-0

```

### AmountDeliquent

```{r message= FALSE, warning=FALSE}
summary(datos$AmountDelinquent)
boxplot(datos$AmountDelinquent, horizontal = T)

```

```{r message= FALSE, warning=FALSE}
# deuda media por cada deuda
media<-as.integer(mean(datos$AmountDelinquent/ifelse(datos$CurrentDelinquencies==0,NA,datos$CurrentDelinquencies), na.rm = TRUE))
datos$AmountDelinquent[is.na(datos$AmountDelinquent)]<-datos$CurrentDelinquencies*media

remove(media)

```


### PublicRecordsLast12Months

```{r message= FALSE, warning=FALSE}
summary(datos$PublicRecordsLast12Months)

```

En este caso, no disponemos de otros datos, imputamos un cero a los valores vacíos.

```{r message= FALSE, warning=FALSE}
datos$PublicRecordsLast12Months[is.na(datos$PublicRecordsLast12Months)]<-0

```

### RevolvingCreditBalance

```{r message= FALSE, warning=FALSE}
summary(datos$RevolvingCreditBalance)

```

Comprobamos si existe correlación con ciertas variables:

```{r message= FALSE, warning=FALSE}
cor(sapply(datos[,c(17,23,29,32)],as.numeric),use="complete.obs")

```

Aunque el coeficiente no es todo lo bueno que se desea, decidimos plantear un modelo que relacione el balance con la cuota de créditos revolving.

```{r message= FALSE, warning=FALSE}
reg.revolving<-lm(RevolvingCreditBalance ~ OpenRevolvingMonthlyPayment,datos,na.action = na.omit)

summary(reg.revolving)

remove(reg.revolving)
```

Se observa que el r2 ajustado del modelo no es bueno.

Se imputa la media.

```{r message= FALSE, warning=FALSE}
datos$RevolvingCreditBalance[is.na(datos$RevolvingCreditBalance)]<-
  mean(datos$RevolvingCreditBalance,na.rm = T)

```

### BankCardUtilization

```{r message= FALSE, warning=FALSE}
summary(datos$BankcardUtilization)

```

Se imputa la media.

```{r message= FALSE, warning=FALSE}
datos$BankcardUtilization[is.na(datos$BankcardUtilization)]<-
  mean(datos$BankcardUtilization,na.rm = T)

```

### AvailableBankcardCredit

```{r message= FALSE, warning=FALSE}
summary(datos$AvailableBankcardCredit)

```

```{r message= FALSE, warning=FALSE}
cor(sapply(datos[,c(25,29,32)],as.numeric),use="complete.obs")

```
Ante la ausencia de relación, se imputa la media.

```{r message= FALSE, warning=FALSE}
datos$AvailableBankcardCredit[is.na(datos$AvailableBankcardCredit)]<-
  as.integer(mean(datos$AvailableBankcardCredit,na.rm = T))

```

### Trades (TradesOpenedLast6Months/TradesNeverDelinquent..percentage./TotalTrades)


```{r message= FALSE, warning=FALSE}
summary(datos$TradesOpenedLast6Months)
summary(datos$TradesNeverDelinquent..percentage.)
summary(datos$TotalTrades)

```

Se comprueba que la mayoría de las financiaciones comerciales no inciden en morosidad.

Comprobamos que los datos totales sean correctos.

```{r message= FALSE, warning=FALSE}
summary(datos$TradesOpenedLast6Months<=datos$TotalTrades)

```

Partimos de que no se han producido este tipo de financiaciones si no hay datos, según lo recogido en el documento facilitado con el dataset.

```{r message= FALSE, warning=FALSE}
datos$TradesOpenedLast6Months[is.na(datos$TradesOpenedLast6Months)]<-0
datos$TradesNeverDelinquent..percentage.[is.na(datos$TradesNeverDelinquent..percentage.)]<-0
datos$TotalTrades[is.na(datos$TotalTrades)]<-datos$TradesOpenedLast6Months

```

Los porcentajes del dataset están dados en tanto por uno.

```{r message= FALSE, warning=FALSE}
summary(datos$DebtToIncomeRatio)
boxplot(datos$DebtToIncomeRatio,horizontal = T)

```

Así, observamos que de media los solicitantes tienen una deuda que representa el 27,6% de sus ingresos.

Se ha creado un modelo para predecir el valor, sin embargo el resultado no ha sido bueno.

```{r message= FALSE, warning=FALSE}
summary(lm(DebtToIncomeRatio~Term+EstimatedEffectiveYield+OpenCreditLines+
             OpenRevolvingMonthlyPayment+InquiriesLast6Months+RevolvingCreditBalance+
             TotalTrades+IncomeRange,datos,na.action=na.omit))

```

Se imputa el valor medio.

```{r message= FALSE, warning=FALSE}
datos$DebtToIncomeRatio[is.na(datos$DebtToIncomeRatio)]<-
  as.integer(mean(datos$DebtToIncomeRatio,na.rm = T))

```

### IncomeRange

```{r message= FALSE, warning=FALSE}
summary(datos$IncomeRange)

```

Todos los datos pertencen a alguno de las categorías de las variables.

### IncomeVerifiable

```{r message= FALSE, warning=FALSE}
summary(datos$IncomeVerifiable)

```

Todos los registros presentan un nivel válido.

Para hacer un análisis riguroso de los perfiles y préstamos, _se va a descartar los perfiles con ingresos no verificables._
El impacto es pequeño, representan el 7,6% de los datos del dataset.

```{r message= FALSE, warning=FALSE}
datos<-subset(datos,IncomeVerifiable=="True")
#eliminamos la columna
datos$IncomeVerifiable<-NULL

```


### StatedMonthlyIncome

```{r message= FALSE, warning=FALSE}
summary(datos$StatedMonthlyIncome)
boxplot(datos$StatedMonthlyIncome, horizontal = T)

```

Se observa que por encima de los 100.000 dólares mensuales no hay un gran número de perfiles. Todo apunta a valor incorrecto, pudiendo ser los ingresos anuales y no los mensuales. No disponemos de datos en base a los cuales realizar la corrección.

En este punto, comprobamos que la información es redundante con la variable IncomeRange, de hecho en este caso tenemos datos de todos los registros. Y podremos consultar si está desempleado, en la variable correspondiente.

```{r message= FALSE, warning=FALSE}
datos$IncomeRange <-NULL

```

### ProsperLoans

Tratamos de forma conjunta los préstamos Prosper anteriores.

```{r message= FALSE, warning=FALSE}
summary(datos$TotalProsperLoans)
summary(datos$OnTimeProsperPayments)
summary(datos$ProsperPrincipalOutstanding)

```

En el caso de la primera variable, al menos el solicitante tendría un préstamo. El que hace que salga en el registro.

```{r message= FALSE, warning=FALSE}
datos$TotalProsperLoans[is.na(datos$TotalProsperLoans)]<-0

```

En el caso de la segunda variable, se comprueba que la mayoría de los solicitante son buenos pagadores.
Imputamos valor 1 a los registros vacíos (se supone que no tienen préstamos previos).

```{r message= FALSE, warning=FALSE}
datos$OnTimeProsperPayments[is.na(datos$OnTimeProsperPayments)]<-1

```

En el caso de la tercera variable, imputamos ceros porque no hay préstamos previos, y por tanto no hay ninguna cantidad pendiente de pago.

```{r message= FALSE, warning=FALSE}
datos$ProsperPrincipalOutstanding[is.na(datos$ProsperPrincipalOutstanding)]<-0

```

Comprobamos también que para la mayoría de solicitantes, esta es la primera vez que piden un préstamos Prosper.

### LoanCurrentDaysDelinquent

```{r message= FALSE, warning=FALSE}
summary(datos$LoanCurrentDaysDelinquent)
boxplot(datos$LoanCurrentDaysDelinquent, horizontal = T)

```

Se observa que no hay valores vacíos. Comprobamos que la mayoría de los préstamos no presentan impagos de las cuotas. Nos interesa mantener los valores  superiores a cero para identificar los préstamos morosos y poder identificar el perfil de solicitante que incurre en morosidad.

### LoanOriginalAmount

```{r message= FALSE, warning=FALSE}
summary(datos$LoanOriginalAmount)

```

Ya se ha graficado previamente, no hay valores vacíos y observamos que la mayoría del dinero solicitado se sitúa en el rango entre 4.000 y 12.000 dólares.

### LoanOriginationDate

```{r message= FALSE, warning=FALSE}
summary(datos$LoanOriginationDate)

```

No hay valores vacíos y son coherentes con respecto al resto de datos.

Hacemos la correlación con respecto a la fecha de creación.

```{r message= FALSE, warning=FALSE}
cor(sapply(datos[,c("ListingCreationDate","LoanOriginationDate")],as.numeric))

```

```{r message= FALSE, warning=FALSE}
summary(lm(ListingCreationDate~LoanOriginationDate, as.data.frame(sapply(datos[,c("ListingCreationDate","LoanOriginationDate")],as.numeric))))
datos$LoanOriginationDate<-NULL

```

Comprobamos que si bien no son idénticos, la semejanza entre ambos valores es muy importante por lo que decidimos eliminar la variable.

### MonthlyLoanPayment

```{r message= FALSE, warning=FALSE}
summary(datos$MonthlyLoanPayment)
boxplot(datos$MonthlyLoanPayment, horizontal = T)

```

No existen valores vacíos. Vemos que el valor máximo es diez veces superior a la media.

### LP

```{r message= FALSE, warning=FALSE}
summary(datos$LP_CustomerPayments)
summary(datos$LP_CustomerPrincipalPayments)
summary(datos$LP_InterestandFees)
summary(datos$LP_ServiceFees)
summary(datos$LP_CollectionFees)
summary(datos$LP_GrossPrincipalLoss)
summary(datos$LP_NetPrincipalLoss)
summary(datos$LP_NonPrincipalRecoverypayments)

par(mfrow=c(2,2))
boxplot(datos$LP_CustomerPayments, horizontal = T)
boxplot(datos$LP_CustomerPrincipalPayments, horizontal = T)
boxplot(datos$LP_InterestandFees, horizontal = T)
boxplot(datos$LP_ServiceFees, horizontal = T)
par(mfrow=c(2,2))
boxplot(datos$LP_CollectionFees, horizontal = T)
boxplot(datos$LP_GrossPrincipalLoss, horizontal = T)
boxplot(datos$LP_NetPrincipalLoss, horizontal = T)
boxplot(datos$LP_NonPrincipalRecoverypayments, horizontal = T)

```

Las variables anteriores se refieren a los diferentes parámetros que catacterizan los préstamos del dataset a analizar.

No existen valores vacíos.

Comprobamos la relación entre estas variables, conociendo de antemano alguna de ellas, por ejemplo _LP_CostumerPayments = LP_CostumerPrincipalPayments + LP_InterestsAndFees_.

```{r message= FALSE, warning=FALSE}
library(corrplot)
#diagrama de correlación
corrplot(cor(datos[,37:44]), type = "upper", order = "hclust", 
         tl.col = "black", tl.srt = 45, na.omit=T)

```

Además de la relación como ejemplo, destaca:
- LP_ServiceFees vs LP_InterestandFees
- LP_GrossPrincipalLoss VS LP_NetPrincipalLoss

De momento no se va a eliminar ninguna de estas varaibles.

### PercentFunded

```{r message= FALSE, warning=FALSE}
summary(datos$PercentFunded)

```

Se comprueba que la mayoría de los préstamos está financiado al 100%.

Se observa que el valor máximo está por encima del 100%, hay que corregir ese valor.

```{r message= FALSE, warning=FALSE}
datos$PercentFunded[datos$PercentFunded>1]<-1

```

### Investors

```{r message= FALSE, warning=FALSE}
summary(datos$Investors)
boxplot(datos$Investors, horizontal = T)

```

### ProsperRating

```{r message= FALSE, warning=FALSE}
summary(datos$ProsperRating)

```

```{r message= FALSE, warning=FALSE}
datos$ProsperRating[datos$ProsperRating==""]<-NA

```

Dejamos pendientes tratar los valores vacíos.

### ListingCategory

```{r message= FALSE, warning=FALSE}
summary(datos$ListingCategory)
plot(datos$ListingCategory)

```

## 3.1. ¿Los datos contienen ceros o elementos vacíos? ¿Cómo gestionarías cada uno de estos casos?

La mayoría de valores vacíos se han corregido durante el tratamiento individual de cada una de las variables. Quedando algunas para este apartado.

```{r message= FALSE, warning=FALSE}
sapply(datos, function(x) sum(is.na(x)))

```

Comprobamos que quedan valores vacíos para 5 variables:

- ProsperScore
- CreditScoreRangeLower
- CreditScoreRangeUpper
- EstimatedEffectiveYield
- ProsperRating
- FirstRecordedCreditLine 

En el caso de esta última y tal y como se indicó, no es posible asignar un valor, ya que la razón es que esos solicitantes nunca han presentado líneas de crédito.

```{r message= FALSE, warning=FALSE}
sapply(datos, function(x) sum(x == ''))

```

Observamos que en el caso de las variables tipo String, hay valores vacíos para BorrowerState, pero tal y como se indicó anteriormente no es posible asignar un valor con los datos disponibles.

Corregimos las variables identificadas:

### EstimatedEffectiveYield

El rendimiento efectivo estimado (EstimatedEffectiveYield) es el rendimiento total que recibe un inversor, en contraste con el rendimiento nominal, que es la tasa de interés establecida de un producto.

```{r message= FALSE, warning=FALSE}
hist(datos$EstimatedEffectiveYield)

```

```{r message= FALSE, warning=FALSE}
summary(lm(EstimatedEffectiveYield ~. ,datos,na.action = na.omit))

```

```{r message= FALSE, warning=FALSE}
reg.lin.eey<-lm(EstimatedEffectiveYield ~Term+LoanStatus+BorrowerAPR+ProsperRating ,datos, na.action = na.omit)

summary(reg.lin.eey)

```

```{r message= FALSE, warning=FALSE}
datos$EstimatedEffectiveYield[is.na(datos$EstimatedEffectiveYield)]<-predict(reg.lin.eey)

remove(reg.lin.eey)

summary(datos$EstimatedEffectiveYield)

```

### CreditScoreRangeLower

```{r message= FALSE, warning=FALSE}
hist(datos$CreditScoreRangeLower)

```

```{r message= FALSE, warning=FALSE}
summary(lm(CreditScoreRangeLower~.,datos,na.action = na.omit))

```

Se logra un R2 ajustado perfecto fundamentalmente por la variable complementaria CreditScoreRangeUpper, ya que ambas van de la mano. El problema reside en que los valores vacíos de una coinciden con los valores vacíos de la otra.

```{r message= FALSE, warning=FALSE}

tabla.credit <- datos %>%                             
     group_by(ProsperRating) %>%
     summarise(count = n(),media=mean(CreditScoreRangeLower,na.rm = T))

rownames(tabla.credit)<-levels(tabla.credit$ProsperRating)

for (i in (1:(dim(datos)[1])))
  {
#asignamos a los valoresvacíos 
      if  (is.na(datos$CreditScoreRangeLower[i])){
        datos$CreditScoreRangeLower[i]<-as.integer(tabla.credit[which(tabla.credit$ProsperRating==datos$ProsperRating[i]),3])
      }
      
}

remove(i,tabla.credit)

summary(datos$CreditScoreRangeLower)

```

Imputamos valores a alguna de los registros vacíos, sin embargo no logramos rellenar todos. ELiminamos los registros vacíos.

```{r message= FALSE, warning=FALSE}
datos<-subset(datos, !(is.na(CreditScoreRangeLower)))

```

### CreditScoreRangeLower

```{r message= FALSE, warning=FALSE}
hist(datos$CreditScoreRangeUpper)

```

```{r message= FALSE, warning=FALSE}
reg.credit<-lm(CreditScoreRangeUpper~CreditScoreRangeLower,datos,na.action = na.omit)

summary(reg.credit)

```

Se logra un R2 ajustado perfecto fundamentalmente por la variable complementaria CreditScoreRangeUpper, ya que ambas van de la mano. El problema reside en que los valores vacíos de una coinciden con los valores vacíos de la otra.

```{r message= FALSE, warning=FALSE}
datos$CreditScoreRangeUpper[is.na(datos$CreditScoreRangeUpper)]<-predict(reg.credit)

remove(reg.credit)

```

### ProsperScore y ProsperRating

Se tratan de manera conjunta porque presentan valores vacíos en los mismos registros.

```{r message= FALSE, warning=FALSE}
summary(datos$ProsperScore)
summary(datos$ProsperRating)

```

Planteamos un modelo de regresión lineal para estimar el Score.

```{r message= FALSE, warning=FALSE}
summary(lm(ProsperScore~.,datos))

```

El modelo no alcanza el coeficiente R2 ajustado mínimo para darlo por bueno. 

No podemos usar KNN para predecir el Rating. El ordenador no es capaz de procesarlo y da un error de tamaño de vector.

```{r message= FALSE, warning=FALSE}
#library(VIM)

#datos$ProsperRating[1:500][datos$ProsperRating[1:500]==""]<-KNN(datos[1:500,])$ProsperRating

```

Eliminamos los valores no procesables.

```{r message= FALSE, warning=FALSE}
datos<-subset(datos,!(is.na(datos$ProsperScore)))
summary(datos$ProsperScore)

datos<-subset(datos,!(datos$ProsperRating==""))
summary(datos$ProsperRating)


```

## 3.2. Identificación y tratamiento de valores extremos.

La detección y tratamiento de outliers ya se tratado para cada una de las variables.

En algunos casos, se han corregido, en otros se ha dejado igual. Como se ha indicado, la ausencia de conocimiento con respecto a la realidad del sector y de los préstamos objetivo de análisis dificulta el análisis y la limpieza del dataset.

Antes de continuar procedemos a exportar los datos limpios a CSV.

```{r message= FALSE, warning=FALSE}
#escribimos el csv
write.csv(datos,file="datoslimpios.csv")

```

# 4. Análisis de los datos.

Se procede al análisis de los datos.

## 4.1. Selección de los grupos de datos que se quieren analizar/comparar (planificación de los análisis a aplicar).

Como parte de la selección de los datos a analizar, comprobamos como se comporta si aplicamos un PCA.

```{r message= FALSE, warning=FALSE}
#convertimos las variables cuantitativas a numerico en base a sus diferentes niveles.
datos.num<-na.omit(scale(sapply(datos , as.numeric)))
PCA<-prcomp(datos.num)

# hacemos el PCA
summary(PCA)

remove(PCA)

```

Observamos como para lograr alcanzar un nivel en el que expliquemos el 70% de la varianza del dataset original necesitamos emplear 17 componentes. Si queremos llegar al 85% necesitaríamos 26 componentes.

Es decir, el PCA podría ser útil para reducir la dimensionalidad del dataset, pero no se consigue una reducción radical.

En este caso, no tiene sentido representar gráficamente las dos primeras componentes del PCA porque la varianza que explican entre las dos es del 21,5% y por el tamaño del dataset sería complicado observar nanda.

Para la realización de los diversos análisis se trabajará con el dataset completo que hemos limpiado y preparado, haciendo los ajustes que sean necesarios para los métodos que se planteen.

## 4.2. Comprobación de la normalidad y homogeneidad de la varianza.

Para la comprobación de que los valores que toman las variables provienen de una población distribuida normalmente, se utiliza la prueba de normalidad de Anderson-Darling.

Así, se comprueba que para que cada prueba se obtiene un p-valor superior al nivel de significación prefijado α = 0, 05. Si esto se cumple, entonces se considera que variable en cuestión sigue una distribución normal.

```{r message= FALSE, warning=FALSE}
datos.normales<-function(datos){

  library(nortest)
  alpha = 0.05
  col.names = colnames(datos)
  for (i in 1:ncol(datos)) {
  if (i == 1) cat("Variables que no siguen una distribución normal:\n")
  if (is.integer(datos[,i]) | is.numeric(datos[,i])) {
  p_val = ad.test(datos[,i])$p.value
  if (p_val < alpha) {
  cat(col.names[i])
  # Format output
  if (i < ncol(datos) - 1) cat(", ")
  if (i %% 3 == 0) cat("\n")
  }
  }
  }
}

datos.normales(datos)

remove(datos.normales)

```

Se comprueba que ninguna de las variables presenta una distribución normal.

Para la comprobación de la homogeneidad de varianzas entre varios grupos,  existen diversos métodos:

- Prueba F: Compare las varianzas de dos muestras. Los datos deben distribuirse normalmente.

- Prueba de Bartlett: compare las varianzas de k muestras, donde k puede ser más de dos muestras. Los datos deben distribuirse normalmente. La prueba de Levene es una alternativa a la prueba de Bartlett que es menos sensible a las desviaciones de la normalidad.

- Prueba de Levene: compare las varianzas de k muestras, donde k puede ser más de dos muestras. Es una alternativa a la prueba de Bartlett que es menos sensible a las desviaciones de la normalidad.

- Test de Fligner-Killeen: test no paramétrico muy robusto frente a desviaciones de la normalidad.

Descartamos los dos primeros test, por disponer de datos que no se distribuyen de manera normal. Usamos Fligner-Killeen por ser uno de los test más robustos para distribuciones no normales. Analizaremos el valor de préstamo solicitado contra el estado del préstamo.

```{r message= FALSE, warning=FALSE}

fligner.test(LoanOriginalAmount ~ LoanStatus, data = datos)

```

Rechazamos la hipótesis nula, por lo que al menos dos de los grupos presentan varianzas diferentes.

Adicionalmente, realizaremos un ANOVA para analizar el comprotamiento de la media de los préstamos solicitados respecto a los diferentes grupos de la variable de estado. Si bien hay que destacar que la varianza dentro de los grupos debería de ser aproximadamente igual en todos ellos. Esto es así ya que en la hipótesis nula se considera que todas las observaciones proceden de la misma población, por lo que tienen la misma media y también la misma varianza.

```{r message= FALSE, warning=FALSE}

summary(aov(LoanOriginalAmount ~ LoanStatus, data = datos))

```

Como el valor p es menor que el nivel de significancia 0.05, podemos concluir que existen diferencias significativas en la media entre los grupos.

```{r message= FALSE, warning=FALSE}

plot(TukeyHSD(aov(LoanOriginalAmount ~ LoanStatus, data = datos)))

```


## 4.3. Aplicación de pruebas estadísticas para comparar los grupos de datos. En función de los datos y el objetivo del estudio, aplicar pruebas de contraste de hipótesis, correlaciones, regresiones, etc. Aplicar al menos tres métodos de análisis diferentes.

### Método 1. Modelo regresión para conocer como se calcula el ProsperScore

Según explican en su [web](https://www.prosper.com/plp/general-prosper_score/), Se creó una puntuación de riesgo personalizada utilizando datos históricos de Prosper para evaluar el riesgo de las listas de prestatarios de Prosper.  A diferencia del score de una agencia de crédito, que se basa en una variedad mucho más amplia de desempeño de préstamos, el puntaje de Prosper se basa específicamente en la población de prestatarios y solicitantes de Prosper. Como tal, el puntaje de la agencia de informes crediticios debe clasificar el riesgo de orden en la población de Prosper. Prosper utiliza conjuntamente la puntuación personalizada y la puntuación de la agencia de informes crediticios para evaluar el nivel de riesgo del prestatario y determinar las tasas de pérdida estimadas.

Las variables clave en el cuadro de mando son:

- Número de consultas al buró de crédito
- Número de cuentas morosas en el buró de crédito
- Utilización de la tarjeta de crédito en el buró de crédito
- Número de operaciones abiertas recientemente en el buró de crédito
- Relación deuda-ingresos
- Rendimiento del pago de préstamos en préstamos anteriores de Prosper


```{r message= FALSE, warning=FALSE}
#trabajaremos solo con los prestamos Current
datos.reg<-subset(datos,LoanStatus=="Current")
datos.reg$LoanStatus<-NULL
#tambien eliminamos de partida ProsperRating por presentar una relación bastante directa según se ha comprobado previamente.
datos.reg$ProsperRating<-NULL

summary(lm(ProsperScore~TotalInquiries+InquiriesLast6Months+CurrentDelinquencies+BankcardUtilization+AvailableBankcardCredit+TotalTrades+TradesNeverDelinquent..percentage.+DebtToIncomeRatio+OnTimeProsperPayments,datos.reg))

```

Comprobamos que solo con esas variables no llegamos al 0.2 en el coeficiente de determinación ajustado. AUnque no es lo óptimo, comprobamos como se comporta si descartamos el intercept.Nunca se debería hacer, a menos que sea seguro que la aproximación lineal del modelo de regresión linea se vea obligada a pasar por el origen. Si no, los otros parámetros de regresión estarán sesgados incluso si la intersección es estadísticamente insignificante. Finalmente, al dejar el término de intersección se asegura de que el término residual sea de media cero.

```{r message= FALSE, warning=FALSE}
model.reg<-lm(ProsperScore~-1+TotalInquiries+InquiriesLast6Months+CurrentDelinquencies+BankcardUtilization+AvailableBankcardCredit+TotalTrades+TradesNeverDelinquent..percentage.+DebtToIncomeRatio+OnTimeProsperPayments,datos.reg)

summary(model.reg)

```

Vemos como así el modelo mejora en términos de R2, sin embargo a la hora de realizar la predicción el resultado es malo.

```{r message= FALSE, warning=FALSE}
summary(as.integer(predict(model.reg,datos.reg))==datos.reg$ProsperScore)

```

Graficamos ambos resultados: 

```{r message= FALSE, warning=FALSE}
datos.grafica <- data.frame(values = c(as.integer(predict(model.reg,datos.reg)),                    # Create example data
                              datos.reg$ProsperScore),
                   group = c(rep("Predicted", 52434),
                             rep("True", 52434)))

ggplot(datos.grafica, aes(x = values, fill = group)) +                       # Draw overlaying histogram
  geom_histogram(position = "identity", alpha = 0.2, bins = 50 + xlim(0,10))

remove(model.reg)

```

Observamos que los modelos únicamente con las variables que reconocen emplear en la web da un resultado pobre.

Observamos como se comporta con un modelo más elaborado:

```{r message= FALSE, warning=FALSE}

summary(lm(ProsperScore~., datos.reg))

```

Comprobamos que el modelo no presenta un coeficiente muy elevado. Lo depuramos al eliminar las variables menos significativas.

```{r message= FALSE, warning=FALSE}

model.reg2<-lm(ProsperScore~.-ClosedDate-BorrowerState-Occupation-CreditScoreRangeUpper-EmploymentStatusDuration-AmountDelinquent-PublicRecordsLast12Months-LoanCurrentDaysDelinquent-LP_InterestandFees-LP_GrossPrincipalLoss-LP_NetPrincipalLoss-LP_NonPrincipalRecoverypayments-LP_CollectionFees-PercentFunded  , datos.reg)

summary(model.reg2)

```

Comprobamos como ha disminuido ampliamente el número de variables, sin embargo el coeficiente R2 ajustado apenas se ha visto afectado.


```{r message= FALSE, warning=FALSE}
summary(as.integer(predict(model.reg2,datos.reg))==datos.reg$ProsperScore)

```

Graficamos ambos resultados: 

```{r message= FALSE, warning=FALSE}
datos.grafica <- data.frame(values = c(as.integer(predict(model.reg2,datos.reg)),                    # Create example data
                              datos.reg$ProsperScore),
                   group = c(rep("Predicted", 52434),
                             rep("True", 52434)))

ggplot(datos.grafica, aes(x = values, fill = group)) +                       # Draw overlaying histogram
  geom_histogram(position = "identity", alpha = 0.2, bins = 50 + xlim(0,10))

remove(model.reg2,datos.reg,datos.grafica)

```

Se comprueba que los resultados si bien mejoran respecto al primer modelo, siguen siendo pobres. Si bien una parte del error podría explicarse por el redondeo necesario para aproximar a un número entero los resultados predichos por el modelo, todo parece indicar que mediante un modelo de regresión lineal multivariable no es posible inferir de manera acertada el ProsperScore. Sería necesario desarrollar métodos más complejos.

### Método 2. Contrastes de hipótesis

Se procede a comparar muestras de los datos para las variables `ProsperScore` y `EmploymentStatus`. Aunque las variables no se distribuyen según una normal, las muestras tienen un tamaño suficientemente grande para asumir normalidad según el Teorema del Límite central.

Se definen las hipótesis nula y alternativa para el caso de comparativa de ProperScore en función del estado de ocupación. Particularmente, se quiere analizar la media de puntuación de prosperidad según si el individuo está, o no, desempleado.

$$
H_0: \mu_1 = \mu_2
$$
$$
H_1: \mu_1 > \mu_2
$$

Donde $\mu_1$ se corresponde con la media del ProsperScore para desempleados y $\mu_2$ con la media del ProperScore para no desempleados. 

En este caso tenemos dos muestras independientes (`ProsperScore` para dos estados ocupacionales) y se desea realizar un test sobre la media. Se aplicará un test de hipótesis de dos muestras sobre la media correspondiendo con un test unilateral por la derecha. 

Se realiza un test de varianza para comprobar si se puede suponer que la varianza de ambas muestras es igual.

```{r echo=TRUE, message=FALSE, warning=FALSE}
var.test(datos$ProsperScore[which(datos$EmploymentStatus=="Not employed")], datos$ProsperScore[which(datos$EmploymentStatus=="Employed")])

```

El resultado de p-value es 0.32, por lo que no podemos descartar la igualdad de varianzas. En consecuencia, se aplica un **test de dos muestras independientes sobre la media con varianzas desconocidas e iguales correspondiendo con un test unilateral por la derecha**.

Por tanto, se pretende contestar a la pregunta de si el ProsperScore medio de los desempleados es igual al ProsperScore medio de los individuos empleados o, por el contrario, es mayor.

```{r echo=TRUE, message=FALSE, warning=FALSE}
test_prosperscore <- t.test(datos$ProsperScore[which(datos$EmploymentStatus=="Not employed")],
                            datos$ProsperScore[which(datos$EmploymentStatus=="Employed")], 
                            var.equal=TRUE, alternative="greater")
data.frame(test_prosperscore[c("statistic", "parameter", "p.value")])

remove(test_prosperscore)

```

El p-value es superior al nivel de significación (0.05). Por tanto, con un nivel de confianza del 95%, se puede aceptar la hipótesis nula (igualdad de media de ProsperScore) y se puede concluir que **el promedio de ProsperScore de los individuos empleados es igual que el promedio de ProsperScore de los desempleados**.

### Método 3. Tree Model para inferir las reglas que permitan identificar si un prestatario será buen pagador o moroso.

Vamos a analizar el árbol que caracteriza a un buen o mal prestatario en base a las variables que definen su perfil financiero. Para ello, cogeremos solo los préstamos que actualmente están en curso.

Basándonos en la variable LoanCurrentDaysDeliquent definiremos una variable secundaria en base a la que responder a la pregunta planteada. Para ello, definiremos un umbral de días; en este caso, lo planteamos para más en base al Term para más de 1/12 se considerará un mal pagador.

En primer lugar, preparamos los dividimos el dataset en una parte para entrenar y otra para validar el modelo. Se seleccionan las variables que se consideran significativas para evitar errores por el tamaño del dataset.

```{r message= FALSE, warning=FALSE}

#seleccionamos el subset
datos.tree<-na.omit(subset(datos,(LoanStatus=="Current" | LoanStatus=="Past Due" |  LoanStatus=="Chargedoff")))
datos.tree$tipoPagador<-1
datos.tree$tipoPagador[datos.tree$LoanCurrentDaysDelinquent>as.integer(datos.tree$Term*30/12)]<-0
datos.tree$tipoPagador<-as.factor(datos.tree$tipoPagador)
summary(datos.tree$tipoPagador)

#elimimanos columnas no válidas
#datos.tree<-datos.tree[,-c(15,10,9,8,4,3,2,1)]
datos.tree<-datos.tree[,c("EstimatedEffectiveYield","ProsperScore","EmploymentStatusDuration","CreditScoreRangeLower","OpenCreditLines","TotalInquiries","CurrentDelinquencies","RevolvingCreditBalance","BankcardUtilization","TotalTrades","TotalProsperLoans","StatedMonthlyIncome","tipoPagador")]

#reordenamos aleatoriamente el dataset

set.seed(1993)
datos_random<-datos.tree[sample(nrow(datos.tree)),]

#conjuntos totales
y<-as.data.frame(datos_random[,dim(datos_random)[2]])
x<-datos_random[,-dim(datos_random)[2]]

split_prop<-2
max_split<-floor(nrow(x)/split_prop)
tr_limit<-nrow(x)-max_split
ts_limit<-nrow(x)-max_split+1

trainX<-x[1:tr_limit,]
trainY<-y[1:tr_limit,]

testX<-x[ts_limit:nrow(x),]
testY<-y[ts_limit:nrow(x),]

```

Creamos el modelo:

```{r message= FALSE, warning=FALSE}

#Volvemos a poner como categórico el subconjunto
trainY<-as.factor(trainY)
#arbol con reglas
tree.model<- C50::C5.0(trainX,trainY,rules =T,na.action=na.omit)
#resumen de reglas
summary(tree.model)

```

El árbol obtenido clasifica erróneamente 2.277 de los 30.138 casos dados, una tasa de error del 7,6%.

```{r message= FALSE, warning=FALSE}
#mismo árbol sin reglas
tree.model<- C50::C5.0(trainX,trainY)

#ploteo del árbol
plot(tree.model)


```

Reducimos las variables a considerar para lograr un árbol que sea fácilmente interpretable a simple vista. Elegimos las cuatro primeras más empleadas en el árbol anterior.

```{r message= FALSE, warning=FALSE}

tree.model2<- C50::C5.0(trainX[,c(1,2,4,6,10)],trainY)

plot(tree.model2)

tree.model2<- C50::C5.0(trainX[,c(1,2,4,6,10)],trainY,rules=T)

summary(tree.model2)

remove(tree.model2)

```

El error crece hasta el 7,8%. Cambia el uso de los atributos, fruto de la reducción de variables cambian las dependencias entre las variables explicativas. De 23 reglas pasamos a 17.

Por tratarse de variables cuantitativas resulta imposible graficarlo de manera que se visualice correctamente la estructura del árbol.

En el apartado anterior, se habían observado varias variables que no presentaban grandes cambios en la proporción de las categorías de default para sus diferentes etiquetas; comprobamos como se comporta el modelo sin ellas.


## Explicación de las reglas obtenidas

A partir del árbol de decisión de dos hojas que hemos modelado, se pueden extraer las siguientes reglas de decisión:

Al coger todas las variables, comprobamos que se generan multitud de reglas, analizamos las reglas que presentan una mayor validez para cada uno de los niveles:

Rule 1: (380, lift 10.2)
	CreditScoreRangeLower <= 620
	TotalProsperLoans <= 0
	->  class 0  [Validez:0.997]

Rule 2: (154, lift 10.2)
	OpenCreditLines > 8
	TotalTrades <= 8
	->  class 0  [Validez:0.994]

Rule 3: (54, lift 10.0)
	EmploymentStatusDuration <= 30
	TotalInquiries > 25
	->  class 0  [Validez:0.982]

Rule 4: (175/4, lift 9.9)
	EstimatedEffectiveYield <= 0.1443
	ProsperScore <= 5
	CreditScoreRangeLower <= 640
	->  class 0  [Validez:0.972]

Rule 5: (29, lift 9.9)
	EstimatedEffectiveYield <= 0.1212251
	CreditScoreRangeLower <= 720
	OpenCreditLines <= 3
	TotalInquiries > 2
	TotalTrades <= 8
	->  class 0  [Validez:0.968]

Rule 25: (7495/248, lift 1.1)
	EstimatedEffectiveYield <= 0.2523
	EmploymentStatusDuration > 30
	CreditScoreRangeLower > 620
	TotalTrades > 8
	StatedMonthlyIncome > 6228.417
	->  class 1  [Validez:0.967]

Rule 26: (29941/2807, lift 1.0)
	TotalInquiries <= 22
	->  class 1  [Validez:0.906]



Y los principales atributos que explican el árbol:

- TotalInquiries
- CreditScoreRangeLower
- EstimatedEffectiveYield
- TotalTrades
- EmploymentStatusDuration
- StatedMonthlyIncome


Las 4 primeras reglas indican que personas incurrirían en morosidad.

Regla 1. Personas con CreditScore por debajo de 621 y sin préstamos Prosper previos.

Regla 2. Personas con más de 8 líneas de crédito abiertas y menos o igual de 8 trades.

Regla 3. Personas con menos de 30 meses trabajados y más de 25 solicitudes de préstamo.

Regla 4. Préstamos con EstimatedEffectiveYield por debajo del 14,43% y personas con ProsperScore igual o inferior a 5 y CreditScore inferior a 640.

Las siguientes reglas para identificar buenos pagadores:

Regla 25. Ingresos mensuales mayores de 6228 dólares, más de 8 trades, más de 620 puntos de crédito, más de 30 meses trabajados y préstamos con EstimatedEffectiveYield por debajo del 25,23%.

Regla 26. Menos de 22 solicitudes.

En resumen, si queremos identificar un buen pagador, tendremos más posibilidades si:

- Nivel de ingresos mensuales alto
- Nivel de CreditScore por encima de 340 puntos.
- Nivel de ProsperScore mayor de 5.
- Pocas solicitudes.

## Análisis de la bondad de ajuste sobre el conjunto de test y matriz de confusión

Comprobamos la calidad del modelo, al predecir los datos que hemos reservado para la validación.

```{r message= FALSE, warning=FALSE}
#predecimos default
predictedY<-predict(tree.model,testX,type="class")

sprintf("La precisión del modelo es: %.2f",sum(testY==predictedY)/length(predictedY)*100)

```

Se obtiene la matriz de confusión a través de la función de la librería caret, que calcula los diferentes parámetros para la evaluación del modelo.

```{r message= FALSE, warning=FALSE}
library(caret)
confusionMatrix(data = predictedY, reference = testY, positive = "1")
remove(x,y,testX,trainX,testY,trainY, datos.tree, tree.model, datos_random)

```



# 5. Representación de los resultados a partir de tablas y gráficas.

Mostramos algunos de los resultados previos y algunos nuevos.

## Perfil de solicitantes

```{r message= FALSE, warning=FALSE}
ggplot(data = datos, aes(x = EmploymentStatus)) +
    geom_bar(fill="red")

```

```{r message= FALSE, warning=FALSE}
tabla.empleo <- datos %>%                             
  group_by(EmploymentStatus) %>%
  summarise(count = n(),media=mean(LoanOriginalAmount))

#ordenado por ocurrences
head(tabla.empleo[order(tabla.empleo$count, decreasing=TRUE),],10)
#ordenado por media de lospréstamos solicitados
head(tabla.empleo[order(tabla.empleo$media, decreasing=TRUE),],10)

remove(tabla.empleo)

```

```{r message= FALSE, warning=FALSE}
ggplot(aes(x = EmploymentStatusDuration) , data = datos) + 
  geom_histogram(aes(), binwidth=12, colour="grey20", lwd=0.2) +
   ggtitle("Distribución de los meses con trabajo") +
  xlab("Meses") + ylab("Ocurrences")

```

Se comprueba que por lo general quienes solicitan préstamos tienen una menor cantidad de tiempo trabajado y Trabajadores por cuenta ajena temporales o indefinidos.

## Perfil de préstamos


```{r message= FALSE, warning=FALSE}
#term
plot(as.factor(datos$Term), main="Distribución por meses solicitados",xlab="Meses", ylab="Ocurrences",col="green")

```

Se observa que de forma mayoritaria se solicitan préstamos a 36 meses.

```{r message= FALSE, warning=FALSE}
library(ggplot2)

ggplot(aes(x = LoanOriginalAmount ) , data = datos) + 
  geom_histogram(aes(), binwidth=1500, colour="red", lwd=0.2) +
   ggtitle("Distribución de las cantidades solicitadas") +
  xlab("Amount ($)") + ylab("Ocurrences")

```

```{r message= FALSE, warning=FALSE}
boxplot(datos$LoanOriginalAmount, horizontal = T, main="Distribución de las cantidades solicitadas")

```

Observamos que predominantemente se trata de préstamos por debajo de los 15.000 dólares.

```{r message= FALSE, warning=FALSE}
ggplot(aes(x = LoanOriginalAmount ) , data = datos) + 
  geom_histogram(aes(fill=IsBorrowerHomeowner), binwidth=1500, colour="grey20", lwd=0.2) +
  scale_x_continuous(breaks=seq(0,max(datos$LoanOriginalAmount), 1500))+
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))+
  xlab("Amount ($)") + ylab("Ocurrences")

```

Se comprueba como en los préstamos que solicitan mayor cantidad, presenta un mayor porcentaje de propietarios de viviendas.

```{r message= FALSE, warning=FALSE}
ggplot(data = datos, aes(x = BorrowerState)) +
    geom_bar(fill="orange")+ theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))




```

## Identificar que préstamos son aquellos en los que más invierten los inversores

```{r message= FALSE, warning=FALSE}
# Basic violin plot
ggplot(datos, aes(x=EstimatedEffectiveYield, y=ProsperRating,color=ProsperRating)) + 
  geom_violin()+ coord_flip() + geom_boxplot(width=0.1)

```

Vemos que cuanto peor es el Rating, más rendimiento esperan lograr los inversores.

```{r message= FALSE, warning=FALSE}
# Basic violin plot
ggplot(datos, aes(x=Investors, y=ProsperRating,color=ProsperRating)) + 
  geom_violin()+ coord_flip() + geom_boxplot(width=0.1)+xlim(0,300)

```

Curiosamente, el número de inversores según Rating, de media es menor en las clases de riesgo intermedio, mayor en las de poco riesgo, y medio en las de mayor riesgo.

## Otras gráficas de interés

```{r message= FALSE, warning=FALSE}
ggplot(datos, aes(x=ProsperScore, y=ProsperRating,color=ProsperRating)) + 
     geom_violin()+ coord_flip() + geom_boxplot(width=0.1)
```

Comprobamos como se relaciona el ProsperRating con el ProsperScore. Destaca el hecho de que el ProsperScore medio es inferior en la categoría E que en el nivel HR (High Risk).

# 6. Resolución del problema. A partir de los resultados obtenidos, ¿cuáles son las conclusiones? ¿Los resultados permiten responder al problema?

Hemos escogido un dataset que solo llegar a entender completamente todas las variables recogidas podría requerir todas las horas de dedicación exigidas para la realización de esta práctica, por ello es probable que no hayamos sabido ver todas las posibilidades de explotación que ofrece el dataset en el ámbito de la minería de datos.

En base al conocimiento adquirido, hemos sido capaces de limpiar el dataset y hemos planteado una serie de gráficas y modelos para tratar de responder a las preguntas planteadas.

Hemos conseguido caracterizar gráficamente y/o en tablas los principales atributos que definen a los prestatarios y a los préstamos solicitados.
También se ha conseguido identificar el perfil inversor de los prestamistas.

No ha sido posible recrear el cálculo del ProsperScore de manera correcta mediante el uso de un modelo de regresión lineal.

Se ha realizado un contraste de hipótesis para demostrar que el Estado laboral (empleado o desempleado) no afecta de media al ProsperScore.

Se han establecido las reglas que permiten detectar a un buen o mal pagador en base a su perfil económico previo.

Así, ha sido posible responder de una manera adecuada a la mayoría de las preguntas. En el caso de la pregunta que no se ha conseguido responder, se ha planteado de manera correcta la posible solución, si bien el resultado no ha sido positivo. Se requiere otro tipo de herramienta de minería más compleja para resolver esta pregunta.

*Destacar el hecho de que si bien el documento supera as 20 páginas de extensión máxima, esto se debe al código y sus resultados; estando la parte explicativa limitada aproximadamente a dicha extensión.*

# 7. Código

El código se ha presentado en los apartados correspondientes y ha sido comentado de cara a explicar su función y poder entender los resultados.

# Contribución

 Contribuciones               Firma
 --------------               --------------
 Investigación previa           DDO, PMP
 Redacción de las repuestas     DDO, PMP
 Desarrollo código              DDO, PMP
